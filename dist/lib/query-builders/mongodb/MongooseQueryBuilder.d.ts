import { IQueryConvention } from '../interfaces/IQueryConvention';
import { MongooseQueryLog } from './MongooseQueryLog';
import { MongooseQuery } from './MongooseQueryBuilder';
import { GenericQueryBuilder, QueryBuilderSoftDelete } from '../GenericQueryBuilder';
import { IBasicQuery } from '../interfaces/IBasicQuery';
import { IFetchResultQuery } from '../interfaces/IFetchResultQuery';
import { Collection } from 'collect.js';
import { Model, Document, DocumentQuery } from 'mongoose';
export declare type MongooseQuery<T> = DocumentQuery<Document & T | null, Document & T> | DocumentQuery<(Document & T)[] | null, Document & T>;
export declare class MongooseQueryBuilder<T extends Object = {}> extends GenericQueryBuilder implements IBasicQuery, IFetchResultQuery<Document & T> {
    static className: string;
    protected mongooseModel: Model<Document & T>;
    protected mongooseQuery: MongooseQuery<T>;
    protected hasMongooseQuery: boolean;
    protected primaryKey: string;
    constructor(modelName: string);
    constructor(modelName: string, softDelete: QueryBuilderSoftDelete | undefined);
    constructor(modelName: string, softDelete: QueryBuilderSoftDelete | undefined, primaryKey: string);
    protected getQuery(isFindOne?: boolean, logger?: MongooseQueryLog): MongooseQuery<T>;
    protected passFieldsToQuery(query: MongooseQuery<T>, logger?: MongooseQueryLog): void;
    protected passLimitToQuery(query: MongooseQuery<T>, logger?: MongooseQueryLog): void;
    protected passOrderingToQuery(query: MongooseQuery<T>, logger?: MongooseQueryLog): void;
    protected passDataToMongooseQuery(query: MongooseQuery<T>, logger?: MongooseQueryLog): MongooseQuery<T>;
    protected createQuery(findOne: boolean, logger?: MongooseQueryLog): DocumentQuery<(Document & T)[] | null, Document & T>;
    getPrimaryKey(): string;
    native(handler: (native: Model<Document & T> | MongooseQuery<T>) => MongooseQuery<T>): IFetchResultQuery<T>;
    toObject(): Object;
    protected getQueryConvention(): IQueryConvention;
    get(): Promise<Collection<any>>;
    all(): Promise<Collection<any>>;
    find(): Promise<any | null>;
    first(): Promise<any | null>;
    pluck(value: string): Promise<Object>;
    pluck(value: string, key: string): Promise<Object>;
    count(): Promise<number>;
    update(data: Object): Promise<Object>;
    delete(): Promise<Object>;
    restore(): Promise<Object>;
    execute(): Promise<any>;
    findOrFail(): Promise<any>;
    firstOrFail(): Promise<any>;
    private isNotUsedOrEmptyCondition();
}
