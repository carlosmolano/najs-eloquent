import { GenericQueryCondition } from './GenericQueryCondition';
import { IQueryConvention } from './interfaces/IQueryConvention';
import { IBasicQuery, OrderDirection } from './interfaces/IBasicQuery';
import { IConditionQuery, SubCondition, Operator } from './interfaces/IConditionQuery';
import { ISoftDeletesQuery } from './interfaces/ISoftDeletesQuery';
export declare type QueryBuilderSoftDelete = {
    deletedAt: string;
};
export declare class GenericQueryBuilder implements IBasicQuery, IConditionQuery, ISoftDeletesQuery {
    protected isUsed: boolean;
    protected name: string;
    protected fields: {
        select: string[];
        distinct: string[];
    };
    protected selectedFields: string[];
    protected distinctFields: string[];
    protected ordering: Object;
    protected limitNumber: number;
    protected conditions: GenericQueryCondition[];
    protected convention: IQueryConvention;
    protected softDelete?: QueryBuilderSoftDelete;
    protected addSoftDeleteCondition: boolean;
    protected logGroup: string;
    constructor(softDelete?: QueryBuilderSoftDelete);
    protected getQueryConvention(): IQueryConvention;
    protected getConditions(): Object[];
    protected flattenFieldNames(...fields: Array<string | string[]>): string[];
    setLogGroup(group: string): this;
    queryName(name: string): this;
    select(field: string): this;
    select(fields: string[]): this;
    select(...fields: Array<string | string[]>): this;
    distinct(field: string): this;
    distinct(fields: string[]): this;
    distinct(...fields: Array<string | string[]>): this;
    orderBy(field: string): this;
    orderBy(field: string, direction: OrderDirection): this;
    orderByAsc(field: string): this;
    orderByDesc(field: string): this;
    limit(records: number): this;
    protected createConditionQuery(convention: IQueryConvention, operator: 'and' | 'or', arg0: string | SubCondition, arg1?: Operator | any, arg2?: any): this;
    where(arg0: string | SubCondition, arg1?: Operator | any, arg2?: any): this;
    orWhere(arg0: string | SubCondition, arg1?: Operator | any, arg2?: any): this;
    whereIn(field: string, values: Array<any>): this;
    whereNotIn(field: string, values: Array<any>): this;
    orWhereIn(field: string, values: Array<any>): this;
    orWhereNotIn(field: string, values: Array<any>): this;
    whereNull(field: string): this;
    whereNotNull(field: string): this;
    orWhereNull(field: string): this;
    orWhereNotNull(field: string): this;
    withTrashed(): this;
    onlyTrashed(): this;
}
